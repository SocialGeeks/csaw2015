
0804851d <main>:
; Setup stack frame as ushual and allocate 20 bytes of space for input
 804851d:	55                   	push   %ebp             ; Backup calling stack frame
 804851e:	89 e5                	mov    %esp,%ebp        ; create new stack frame
 8048520:	83 e4 f0             	and    $0xfffffff0,%esp ; align stack on 4-bit boundry
 8048523:	81 ec a0 00 00 00    	sub    $0xa0,%esp       ; allocate 20 bytes for ???

; I am not sure what is going on here exactly, Loads a float from some constant
; and stores it a ways above our 20 byte [INPUT] space. Stack Cookie?
 8048529:	dd 05 90 86 04 08    	fldl   0x8048690        ; load float from address 64.33333...? 
 804852f:	dd 9c 24 98 00 00 00 	fstpl  0x98(%esp)       ; store float at esp+90 (above our 20bytes)


; Next Few Lines: setvbuf(stdout, NULL, _IONBF, NULL);
; They are just setting stdout to unbuffered. that is all
 8048536:	a1 40 a0 04 08       	mov    0x804a040,%eax   ; Pointer to STDOUT@LIBC
 804853b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)   ; 4rd Argument: NULL - Size of buffer
 8048542:	00 
 8048543:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)   ; 3nd Argument: _IONBF - UNBUFFERED
 804854a:	00 
 804854b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)   ; 2nd Argument: NULL - Buf
 8048552:	00 
 8048553:	89 04 24             	mov    %eax,(%esp)      ; 1st Argumnet: stdout - Pointer to buffer
 8048556:	e8 a5 fe ff ff       	call   8048400 <setvbuf@plt>


; Print the "Buff: X" where x is the value stored in 0x18(%esp) i think
; printf("Buff: %p", 0x18(%esp))
 804855b:	8d 44 24 18          	lea    0x18(%esp),%eax  ; Get a pointer to some local variable
 804855f:	89 44 24 04          	mov    %eax,0x4(%esp)   ; store the pointer 
 8048563:	c7 04 24 78 86 04 08 	movl   $0x8048678,(%esp) ; "Buff: %p"
 804856a:	e8 41 fe ff ff       	call   80483b0 <printf@plt>

; Call SCANF reading from STDIN, wrting to X (the same value that was pritned above)
; scanf("%s", 0x18(%esp))
 804856f:	8d 44 24 18          	lea    0x18(%esp),%eax ; The input buffer address
 8048573:	89 44 24 04          	mov    %eax,0x4(%esp)  ; argument
 8048577:	c7 04 24 82 86 04 08 	movl   $0x8048682,(%esp) ; Pointer to string constant "%s"
 804857e:	e8 8d fe ff ff       	call   8048410 <__isoc99_scanf@plt>

; Stack Cookie Test??
 8048583:	dd 84 24 98 00 00 00 	fldl   0x98(%esp) ; put stack cookie into st0
 804858a:	dd 05 90 86 04 08    	fldl   0x8048690  ; put stack cookie truth in st1
 8048590:	df e9                	fucomip %st(1),%st; compair st1 and st0
 8048592:	dd d8                	fstp   %st(0)     ; Not sure
 8048594:	7a 13                	jp     80485a9 <main+0x8c> ; GO TO LABEL __FAIL_STACK_COOKIE

; More stack cookie?
 8048596:	dd 84 24 98 00 00 00 	fldl   0x98(%esp) ; put stack cookie into st0
 804859d:	dd 05 90 86 04 08    	fldl   0x8048690  ; put stack cookie truth in st1
 80485a3:	df e9                	fucomip %st(1),%st; compair st1 and st0
 80485a5:	dd d8                	fstp   %st(0)     ; Not sure
 80485a7:	74 18                	je     80485c1 <main+0xa4> ; GO TO LABEL __PASS_STACK_COOKIE

; LABEL: __FAIL_STACK_COOKIE
; puts("Nope");
 80485a9:	c7 04 24 85 86 04 08 	movl   $0x8048685,(%esp) ; String Constant "Nope" << Failed stack cookie?
 80485b0:	e8 0b fe ff ff       	call   80483c0 <puts@plt>

; Exit with error
; exit(1)
 80485b5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)  
 80485bc:	e8 1f fe ff ff       	call   80483e0 <exit@plt>

; LABEL: __PASS_STACK_COOKIE
; printf("Got %s", X) - where x is the same buffer for SCANF call above.
 80485c1:	a1 30 a0 04 08       	mov    0x804a030,%eax ; Pointer to "Got %s"
 80485c6:	8d 54 24 18          	lea    0x18(%esp),%edx ; pointer to X (Same buffer as above)
 80485ca:	89 54 24 04          	mov    %edx,0x4(%esp) ; Pass args to printf
 80485ce:	89 04 24             	mov    %eax,(%esp)
 80485d1:	e8 da fd ff ff       	call   80483b0 <printf@plt>

; the usual return stuff
 80485d6:	c9                   	leave  
 80485d7:	c3                   	ret    
